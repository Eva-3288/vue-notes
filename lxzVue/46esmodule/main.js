//通过main.js来引其他的js

/* import引入//-------------
引入的时候：
1.如果是第三方模块，不需要加 ./
2.如果是文件模块（自己写的js）需要加 ./ 
*/

/*//--------------------
    import './a.js';   
    //这里 .js 可以省略，这只是引入了js，但是要直接在这个js文件用a.js里的导出，需要放到变量上；
    //let a = require('./a.js');    //就像这里的commonjs写法，commonjs里的写法，带有变量a 
*/

// -----------------------
    console.log(str1);  //import 具有提升效果，可以预解析；可以在import前拿到;
    import {str1,a as b,c} from './a.js';   
    // a.js里会将str1 和 str2放到一个对象里导出，所以这里引入的时候，应该放一个 对象  和 a.js 相匹配
    // 这样的写法用到了  解构赋值：在另一个文件中将内容结构出来即可使用

    // import a from './a.js';     //这样写需要在 a.js里写一个名字是default的导出，作为默认导出

    console.log(str1);
    b();   //引入的方法名要和导出的一样，可用as 修改命名
    c();
    //问题1：上面的写法很复杂，要导出的变量很多时很麻烦；
    //注意1：而且  import {str1} from './a.js';   里面的结构赋值 let {str1} = {str1:111};相当于把str1声明过了，下面就不能再声明这个变量了
            //import 拥有声明功能，下面就不能再声明和他一样的变量了；
    //注意2：import 具有提升效果，可以预解析；可以在import前拿到;但最好import放到顶部；

// ---------------------------------------------
    // 作为一个对象引入 
    import * as d from './b.js';
    // * 代表输出的所有的， as b 这样写b就是一个对象了（导出所有的放到* 中，并重命名为d）
    console.log(d.str3);

    import m from './b.js'; //k 是b.js里 export default后面的内容，后面是个对象，所以k是个对象
    console.log(m);
    

//-------------------------
import xx from './c.js';
console.log(xx);



// esmodule 的要求：1.要求谷歌必须62以上的（而且es6语法，箭头函数什么的解析不了）

/* 
我们希望：
1.语法问题，可以把高级语法转成低版本语法，babel 翻译器，可以把es6,es7 翻译成es5
2.模块问题：代码中可能会有import语法，这在低版本浏览器也不认识，我们希望模块 转成闭包 ，webpack--一个打包器
 */

/* webpack 是一个 模块加载器  兼  打包工具（可以把各种资源js，css进行自动编译）

雪碧图还是要发请求，如果图片比较小的，我们希望转成base64，这样就可以不发请求了，都可以用webpack

1. webpack 是基于commonjs的规范来写的，写法是node的写法，但对AMD，cmd 也支持；
2.能被模块化的不仅仅是js（以前模块只针对js文件），webpack也可以支持图片，css,less,sass
3.我们写的代码怕被别人拷走，所以上线的时候打包，混淆压缩；还可以图片转base64等，能替代部分gulp的工作；
4.写代码时以保持，页面就自动更新，不用刷浏览器，刷浏览器很耗性能；

webpack -模块处理器：处理各种依赖关系，天然可以处理模块的问题 */